# Simple Social media REST api 

## **Handling Exceptions with `@ControllerAdvice`**
* [Get Started with Custom Error Handling in Spring Boot (Java)](https://auth0.com/blog/get-started-with-custom-error-handling-in-spring-boot-java/)
* [Spring Boot Error Handling: A Step-by-Step Guide](https://inspector.dev/spring-boot-error-handling-a-step-by-step-guide/)

## [springdoc-openapi v2.8.13](https://springdoc.org/)
* using springdoc swagger api to  automate the generation of API documentation using spring boot projects.

## [Validation in Spring Boot](https://www.baeldung.com/spring-boot-bean-validation)
* Front end validation is never a good option so we need a better way to validate the incoming request.

## [Spring Boot and Content Negotiation - XML and JSON Representations](https://www.springboottutorial.com/spring-boot-content-negotiation-with-xml-json-representations)
A resource can have multiple representations
* XML
* HTML
* JSON

## Internationalization i18n 
* Typically, HTTP request header - `Accept-Language` is used
* Accept-Language indicates natural language and locale that consumer prefers
* [Decoding i18n Challenges in Spring Boot 3: Exploring Internationalization](https://medium.com/yildiztech/decoding-i18n-challenges-in-spring-boot-3-exploring-internationalization-895a4ac627df)
* [Spring Boot internationalization i18n](https://lokalise.com/blog/spring-boot-internationalization/)
* [Guide to Internationalization in Spring Boot](https://www.baeldung.com/spring-boot-internationalization)


## Hateoas 
```     
@GetMapping("/users/{id}")
public EntityModel<User> retrieveUser(@PathVariable int id){
  User user = service.findOne(id);
  if(user == null){
      throw new UserNotFoundException("id: " + id);
  }
  EntityModel<User> entityModel =  EntityModel.of(user);
  WebMvcLinkBuilder link = WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(this.getClass()).retrieveAllUsers());
  entityModel.add(link.withRel("all-users"));
  return entityModel;
}
```

* using hateoas to send navigation links along with the response 
* `User` is wrapped with `EntityModel` 
* Links are added using `WebMvcLinkBuilder` to the `EntityModel`


## Customizing REST api response 
* Customizing field names in response with `@JsonProperty("user_name")`
* Return only selected fields with 
  * **Static Filtering**
    * `@JsonIgnoreProperties({"filed1", "field2"})` class level, `@JsonIgnore` on methods
  * **Dynamic Filtering**
    * `@JsonFilter` with `FilterProvider`

## [Actuator](https://www.baeldung.com/spring-boot-actuators)
monitor and manage your application in production, Monitoring our app, gathering metrics, and understanding traffic or the state of our database becomes trivial with this dependency.
```
management.endpoints.web.exposure.include=*
management.endpoint.env.show-values=ALWAYS
```

## HAL (JSON Hypertext Application Language)
* Simple format that gives consistent and easy way to hyperlink between resources in your API
### HAL Explorer 
* An API explorer for RESTful Hypermedia using HAL
### Spring Boot HAL Explorer
* autoconfigures HAL Explorer for spring boot projects
* spring-data-rest-hal-explorer

## H2 Database with JPA
> spring.datasource.url=jdbc:h2:mem:testdb

>     spring.jpa.defer-datasource-initialization=true 
> defer initialization of data source and execution of `data.sql`

>     spring.jpa.show-sql=true
> show all the sql queries generated by jpa
      
## Connecting to mysql database
>      spring.jpa.hibernate.ddl-auto=update 
> spring boot autoconfiguration won't automatically create all the schema based on the entity when using mysql 
    
```
spring.datasource.url=jdbc:mysql://localhost:3306/social-media-database
spring.datasource.username=social-media-user
spring.datasource.password=dummypassword
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

`/social-media-database` is the name of the database
>     docker run --detach --env MYSQL_ROOT_PASSWORD=dummypassword --env MYSQL_USER=social-media-user --env MYSQL_PASSWORD=dummypassword --env MYSQL_DATABASE=social-media-database --name mysql --publish 3306:3306 mysql:8-oracle
> command to create a new docker container

>     spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect
>  This dialect informs Hibernate about the specific SQL syntax and features supported by the underlying database, allowing it to generate optimized SQL queries.
> 

## Spring Security
>     spring.security.user.name=user 
>     spring.security.user.password=dummy
> to configure the default username and password 

* Spring security puts series of filter chains with `Cross Site Request Forgery (CSRF)` protecting the put / post request.
#### If you want to override the existing the filter chain you have to define the filter chain yourself
``` 
@Configuration
public class SpringSecurityConfiguration {
  @Bean
  public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
    return httpSecurity.build();
  }
}
```
* using the above configuration disables all the filter chains so we have to configure it manually by adding
1. All the request should be authenticated
2. If request is not authenticated a webpage is shown
3. CSRF -> POST, PUT

```
@Configuration
public class SpringSecurityConfiguration {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
//      1. All the request should be authenticated
        httpSecurity.authorizeHttpRequests(auth-> auth.anyRequest().authenticated());
//      2. If request is not authenticated a webpage is shown
        httpSecurity.httpBasic(Customizer.withDefaults());
//      3. CSRF -> POST, PUT 
        httpSecurity.csrf().disable();
        return httpSecurity.build();
    }
}
```

>     httpSecurity.httpBasic(Customizer.withDefaults());
>    creates basic popup with username and password 
`.csrf() is deprecated` and should be avoided